#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Interactive script to apply updates listed in
`server/sql/update_mind_suggestions.sql` to the database.

Features:
- Parses UPDATE statements generated by suggest_tags_summary.py
- Shows a summary of IDs and proposed changes
- Backs up current rows to `backup_mind_records_<ts>.json`
- Generates rollback SQL with previous values
- Executes updates after explicit confirmation

Usage:
  python apply_update_suggestions.py [--sql path/to/update_mind_suggestions.sql]

Note: The script uses pymysql and will prompt for DB credentials if not provided.
"""
import re
import os
import sys
import json
import time
import getpass
from argparse import ArgumentParser

try:
    import pymysql
except Exception:
    print('Missing dependency: pymysql. Install in your venv: pip install pymysql')
    raise

SQL_DEFAULT = os.path.join(os.path.dirname(__file__), '..', 'sql', 'update_mind_suggestions.sql')

def parse_updates(sql_text):
    # Find UPDATE ... SET tags = '...json...' , category = '...' WHERE id = '...';
    pattern = re.compile(r"UPDATE\s+mind_knowledge\s+SET\s+tags\s*=\s*'(?P<tags>.*?)'\s*,\s*category\s*=\s*'(?P<category>.*?)'\s+WHERE\s+id\s*=\s*'(?P<id>[^']+)';", re.S|re.I)
    matches = list(pattern.finditer(sql_text))
    out = []
    for m in matches:
        tags_raw = m.group('tags')
        # tags_raw is JSON text like ["a","b"] but may contain escaped quotes
        try:
            tags = json.loads(tags_raw)
        except Exception:
            # fallback: try eval-like parsing
            tags = tags_raw
        category = m.group('category')
        rid = m.group('id')
        out.append({'id': rid, 'tags': tags, 'category': category})
    return out

def read_sql_file(path):
    with open(path, 'r', encoding='utf-8') as f:
        return f.read()

def prompt_yesno(msg):
    ans = input(msg + ' [y/N]: ').strip().lower()
    return ans == 'y' or ans == 'yes'

def backup_rows(conn, ids):
    cur = conn.cursor()
    q = "SELECT * FROM mind_knowledge WHERE id IN %s"
    cur.execute(q, (tuple(ids),))
    rows = cur.fetchall()
    cols = [d[0] for d in cur.description]
    out = [dict(zip(cols, r)) for r in rows]

    # Convert non-JSON-serializable types (datetime, date, Decimal, bytes, etc.)
    def make_serializable(val):
        try:
            import datetime, decimal
        except Exception:
            datetime = None; decimal = None
        if val is None:
            return None
        # datetime/date -> ISO format
        if datetime and isinstance(val, (datetime.datetime, datetime.date, datetime.time)):
            try:
                return val.isoformat()
            except Exception:
                return str(val)
        # Decimal -> float (or string if too big)
        if decimal and isinstance(val, decimal.Decimal):
            try:
                return float(val)
            except Exception:
                return str(val)
        # bytes -> decode
        if isinstance(val, (bytes, bytearray)):
            try:
                return val.decode('utf-8')
            except Exception:
                return val.decode('latin-1', errors='ignore')
        # other basic types are fine
        if isinstance(val, (str, int, float, bool)):
            return val
        # fallback to string
        try:
            return str(val)
        except Exception:
            return None

    serializable_out = []
    for row in out:
        newrow = {}
        for k, v in row.items():
            newrow[k] = make_serializable(v)
        serializable_out.append(newrow)

    ts = time.strftime('%Y%m%d_%H%M%S')
    fn = f'backup_mind_records_{ts}.json'
    with open(fn, 'w', encoding='utf-8') as f:
        json.dump(serializable_out, f, ensure_ascii=False, indent=2)
    print('Backed up', len(serializable_out), 'rows to', fn)
    return out, fn

def make_rollback_sql(rows):
    # rows: list of dicts representing original row state
    stmts = []
    for r in rows:
        idv = r.get('id')
        tags = r.get('tags')
        # ensure tags serialized as JSON string
        tags_str = json.dumps(tags, ensure_ascii=False) if tags is not None else ''
        category = r.get('category') or ''
        # escape single quotes
        tags_esc = tags_str.replace("'","\\'")
        cat_esc = str(category).replace("'","\\'")
        stmts.append(f"UPDATE mind_knowledge SET tags = '{tags_esc}', category = '{cat_esc}' WHERE id = '{idv}';")
    ts = time.strftime('%Y%m%d_%H%M%S')
    fn = f'rollback_mind_records_{ts}.sql'
    with open(fn, 'w', encoding='utf-8') as f:
        f.write('-- Rollback statements generated before applying updates\n')
        for s in stmts:
            f.write(s + '\n')
    print('Rollback SQL written to', fn)
    return fn

def apply_updates(conn, updates):
    cur = conn.cursor()
    for u in updates:
        idv = u['id']
        tags = u['tags']
        # ensure tags are json string
        tags_str = json.dumps(tags, ensure_ascii=False)
        tags_esc = tags_str.replace("'","\\'")
        cat_esc = u['category'].replace("'","\\'")
        sql = f"UPDATE mind_knowledge SET tags = '{tags_esc}' , category = '{cat_esc}' WHERE id = '{idv}'"
        print('Executing:', sql[:120] + ('...' if len(sql)>120 else ''))
        cur.execute(sql)
    conn.commit()
    print('Applied', len(updates), 'updates')

def main():
    ap = ArgumentParser()
    ap.add_argument('--sql', default=SQL_DEFAULT)
    ap.add_argument('--host', default='127.0.0.1')
    ap.add_argument('--port', default=3306, type=int)
    ap.add_argument('--user', default='root')
    ap.add_argument('--db', default='july')
    ap.add_argument('--password', default=None, help='Optional: supply DB password on command line (visible in process list)')
    args = ap.parse_args()

    if not os.path.exists(args.sql):
        print('SQL file not found:', args.sql)
        sys.exit(1)

    sql_text = read_sql_file(args.sql)
    updates = parse_updates(sql_text)
    if not updates:
        print('No updates parsed from', args.sql)
        sys.exit(1)

    print('Parsed', len(updates), 'updates:')
    for u in updates:
        print('-', u['id'], '-> tags=', u['tags'], ' category=', u['category'])

    if not prompt_yesno('Proceed to connect to DB and apply these updates?'):
        print('Aborted by user')
        sys.exit(0)

    # Prefer explicit --password if provided (note: passing password on CLI can be visible in process list)
    if args.password:
        pwd = args.password
    else:
        pwd = getpass.getpass('DB password for %s@%s: ' % (args.user, args.host))
    conn = pymysql.connect(host=args.host, port=args.port, user=args.user, password=pwd, db=args.db, charset='utf8mb4')

    ids = [u['id'] for u in updates]
    # backup
    orig_rows, backup_file = backup_rows(conn, ids)
    rollback_file = make_rollback_sql(orig_rows)

    print('\nRollback file generated:', rollback_file)
    if not prompt_yesno('Apply updates now?'):
        print('Cancelled after backup. You can restore using rollback SQL if needed.')
        conn.close()
        sys.exit(0)

    try:
        apply_updates(conn, updates)
    except Exception as e:
        print('Error while applying updates:', e)
        print('You can restore using', rollback_file)
    finally:
        conn.close()

if __name__ == '__main__':
    main()
